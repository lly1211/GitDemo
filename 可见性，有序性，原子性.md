## 可见性

  ```java
public class ThreadDemo1{

private  static  boolean running =  ture;
 

private static void  dowhile(){
    System.out.println("Thread start!")
        while(running) {
            
        }
     System.out.println("Thread end !")
    
}

public static void main(String[] args) throw IOException{
    new Thread(ThreadDemo1:dowhile, "t1").start();
    SleepHelper.sleepSeconds(1);
    running = false;
    System.in.read();
}
    
}
  ```



running 在主内存中 默认为TURE，

线程执行的时候 会把running的值copy到线程本地 也就是CPU的本地  线程放在CPU里面执行

CPU都拥有running的一份拷贝， CPU每次循环的时候 不会跟主内存进行同步 （每次不去主内存读取running的值）。

另外一个线程改变running值时， 也只会改本地的值，  不会去更改主内存中的值（未知时间），while线程里面读取主内存的值（未知时间）

CPU操作手册，触发内存的同步更新。  一个线程里面改变了某个变量的值，不能在另一个线程及时的看到 这个叫做线程的不可见  （保证可见加上volatile）

某些操作会触发 缓存和内存的同步 （java代码 会翻译成汇编语句  ， 这些汇编语句可能会触发 同步）  （println 里面有个  synchronized）

### 二进制码

```
class T｛
 int m =  8 ;
｝
T t = neW T)();

二进制码
0 new #2<T>  申请空间    m = 0 (中间态，默认值)
3 dup
4 invokespecial #3 <T.<init>>    m = 8  
7 astore_1  建立关联
   也可能先建立关联再赋值  （指令重排序）
8 return
```



### this溢出

## 了解缓存行