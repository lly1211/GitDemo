## 可见性

  ```java
public class ThreadDemo1{

private  static  boolean running =  ture;
 

private static void  dowhile(){
    System.out.println("Thread start!")
        while(running) {
            
        }
     System.out.println("Thread end !")
    
}

public static void main(String[] args) throw IOException{
    new Thread(ThreadDemo1:dowhile, "t1").start();
    SleepHelper.sleepSeconds(1);
    running = false;
    System.in.read();
}
    
}
  ```



running 在主内存中 默认为TURE，

线程执行的时候 会把running的值copy到线程本地 也就是CPU的本地  线程放在CPU里面执行

CPU都拥有running的一份拷贝， CPU每次循环的时候 不会跟主内存进行同步 （每次不去主内存读取running的值）。

另外一个线程改变running值时， 也只会改本地的值，  不会去更改主内存中的值（未知时间），while线程里面读取主内存的值（未知时间）

CPU操作手册，触发内存的同步更新。  一个线程里面改变了某个变量的值，不能在另一个线程及时的看到 这个叫做线程的不可见  （保证可见加上volatile）

某些操作会触发 缓存和内存的同步 （java代码 会翻译成汇编语句  ， 这些汇编语句可能会触发 同步）  （println 里面有个  synchronized）

## 有序性

### 二进制码



![image-20210114231947658](C:\Users\lly\AppData\Roaming\Typora\typora-user-images\image-20210114231947658.png) 



![image-20210114232024773](C:\Users\lly\AppData\Roaming\Typora\typora-user-images\image-20210114232024773.png)

```
class T｛
 int m =  8 ;
｝
T t = neW T)();

二进制码
0 new #2<T>  申请空间    m = 0 (中间态，默认值)
3 dup
4 invokespecial #3 <T.<init>>    m = 8  
7 astore_1  建立关联
   也可能先建立关联再赋值  （指令重排序）
8 return
```



### this溢出



##  原子性

​	CAS  compareAndSet   

​	例子：

```java
// reentrantLock中 非公平锁
final void lock() {
            if (compareAndSetState(0, 1))
                 
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }


//compareAndSetState 方法
 protected final boolean compareAndSetState(int expect, int update) {
        // See below for intrinsics setup to support this
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
    }

发现是C/C++写的代码
        public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
由 native 修饰

    
```



相关JVM的实现

```c++
 Atomic:cmpxchg  (comparexchange)
 中_asm_（代表汇编语言）修饰的
     LOCK_IF_MP  'cmpxchg' 
     'cmpxchg'  --> 这个是CPU的 原语  意味着 cpu直接支持CAS  但是这个指令不能保证原子性
      MP --> 是多核的意思
     图中  lock（cpu指令） 起到作用
     lock -->
      1. 锁定缓存行 （缓存锁）
      2. 锁定总线 
      3. lock后面的指令 能保证其原子性
     
```

![image-20210118223817157](C:\Users\lly\AppData\Roaming\Typora\typora-user-images\image-20210118223817157.png)

## 了解缓存行

​	cpu读取数据时，会一块（一行）的读取 而不是一个  所以称为 cacheline  一次64bytes



​	同步机制： 如果一个行被多个cpu 读取之后 需要保证**缓存行对齐**



所以保证被更新的值 处于单独的一个缓存行中，则cpu在进行操作的同时，不会被其他同步消息所打扰，效率会变快





JUC核心  CAS+AQS 

### 并发编程的框架：distruptor